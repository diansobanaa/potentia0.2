*** LOGIKA MENYUSUN ULANG ORDER BLOCK***

Catatan untuk Developer (AI atau Manusia): Logika Reordering Block

Masalah yang Dipecahkan: Kita perlu mengizinkan pengguna untuk menyusun ulang block di dalam canvas. Menggunakan index bilangan bulat (integer) (0, 1, 2, 3...) adalah ide yang buruk. Jika kita memindahkan item dari posisi 10 ke posisi 0, kita harus memperbarui (UPDATE) 10 baris di database untuk menggeser index yang lain. Ini lambat, rumit, dan rawan race condition.

Solusi: "Fractional Indexing" (Pengindeksan Pecahan)

Solusinya adalah menggunakan bilangan pecahan (float atau double precision) untuk kolom y_order.

Status Kesiapan Sistem (Database & Model): Sistem ini SUDAH SIAP untuk "Fractional Indexing". File backend/app/models/block.py (yang ada di Canvas) sudah mendefinisikan y_order sebagai float:

    Di BlockCreate: y_order: Optional[float] = 0.0

    Di BlockUpdate: y_order: Optional[float] = None

    Di Block: y_order: float

Database Supabase (tabel Blocks) harus memiliki kolom y_order yang tipenya float atau numeric untuk mendukung ini.

Arsitektur Logika (Pemisahan Tugas)

Kunci dari arsitektur ini adalah pemisahan tugas yang jelas antara Frontend dan Backend.

1. Tugas Backend (FastAPI)

Tugas backend sangat sederhana:
"block_id": "d1a3df13-7c35-4241-bde4-feb7668b8702",
    "canvas_id": "e10f68e9-5947-4429-aaf1-e3c01549dab7",

    Mengambil Blocks: Saat Frontend meminta daftar block (GET /.../blocks/), Backend HARUS mengembalikannya dalam urutan yang benar. Fungsi get_blocks_in_canvas (di block_queries.py) harus selalu menggunakan .order("y_order").

    Memperbarui Block: Saat Frontend mengirim permintaan PATCH /.../blocks/{block_id} dengan data {"y_order": 1.5}, Backend HANYA perlu memperbarui satu baris itu.

Backend TIDAK PERLU tahu-menahu tentang logika "menggeser" item lain. Logika di endpoints/blocks.py dan queries/block_queries.py (yang ada di Canvas) sudah cukup dan tidak perlu diubah.

2. Tugas Frontend (Next.js)

Semua "otak" dari logika reordering ada di Frontend (Aplikasi React/Next.js Anda).

Saat pengguna menyeret Block B dan melepaskannya di posisi baru, Frontend harus:

    Melihat block "tetangga" barunya: block tepat di atasnya (prev) dan block tepat di bawahnya (next).

    Menghitung nilai y_order baru berdasarkan tetangganya.

    Mengirim satu panggilan API PATCH ke backend dengan y_order baru tersebut.

Skenario Perhitungan di Frontend

Asumsi Database Awal:

    Block A: { "id": "uuid-A", "y_order": 1.0 }

    Block B: { "id": "uuid-B", "y_order": 2.0 }

    Block C: { "id": "uuid-C", "y_order": 3.0 }

Skenario 1: Pengguna memindahkan Block B ke antara A dan C (tidak berubah posisi, hanya contoh).

    Frontend melihat prev = Block A (1.0)

    Frontend melihat next = Block C (2.0)

    y_order_baru = (prev.y_order + next.y_order) / 2

    y_order_baru = (1.0 + 2.0) / 2 = 1.5

    Panggilan API: PATCH /.../blocks/{uuid-B} dengan body: {"y_order": 1.5}

Database Sekarang: A (1.0), B (1.5), C (2.0)

Skenario 2: Pengguna memindahkan Block A ke posisi paling atas (di atas B).

    Stok saat ini: B (1.5), C (2.0)

    Frontend melihat prev = null (karena paling atas)

    Frontend melihat next = Block B (1.5)

    y_order_baru = (0 + next.y_order) / 2 (Kita anggap ada nilai "0" di atas item pertama)

    y_order_baru = (0 + 1.5) / 2 = 0.75

    Panggilan API: PATCH /.../blocks/{uuid-A} dengan body: {"y_order": 0.75}

Database Sekarang: A (0.75), B (1.5), C (2.0)

Skenario 3: Pengguna memindahkan Block B ke posisi paling bawah (di bawah C).

    Stok saat ini: A (0.75), C (2.0)

    Frontend melihat prev = Block C (2.0)

    Frontend melihat next = null (karena paling bawah)

    y_order_baru = prev.y_order + 1.0 (Kita cukup tambahkan 1.0 ke item terakhir)

    y_order_baru = 2.0 + 1.0 = 3.0

    Panggilan API: PATCH /.../blocks/{uuid-B} dengan body: {"y_order": 3.0}

Database Sekarang: A (0.75), C (2.0), B (3.0)

Keuntungan Arsitektur Ini

    Performa Tinggi: Memindahkan satu item hanya membutuhkan satu panggilan API (PATCH) dan satu operasi UPDATE di database, tidak peduli seberapa besar daftarnya.

    Logika Backend Sederhana: Backend Anda tetap "bodoh". Ia tidak perlu tahu tentang list atau reordering, ia hanya tahu cara memperbarui satu block. Ini membuat kode di endpoints/blocks.py dan queries/block_queries.py (yang ada di Canvas) sangat bersih.

    Tangguh: Karena kita menggunakan float, kita bisa terus membagi dua index untuk waktu yang sangat lama sebelum kehabisan presisi (1.0, 1.5, 1.25, 1.125, 1.0625, ...).


=> BAgaimana cara render block dari teks gemini ke canvas